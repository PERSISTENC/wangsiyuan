## 浏览器缓存
浏览器每次发起请求得时候，会在本地缓存中查找结果以及缓存标识，根据缓存标识来判断是否使用本地缓存。如果缓存有效，则使
用本地缓存；否则，则向服务器发起请求并携带缓存标识。根据是否需向服务器发起HTTP请求，将缓存过程划分为两个部分：
强制缓存和协商缓存，强缓优先于协商缓存。
### 强缓存
服务器会通知浏览器缓存一个时间，如果在该时间缓存，直接走缓存，不用发送给服务端，如果过期了 就会重新发起
### 协商缓存
服务器会设置一个` Etag `和 ` Last-Modified `,在第二次请求得时候服务端会检验，如果资源有更新，重新下发字段，资源没更新，会直接返回308 通过浏览器从缓存里面读取缓存
## LocalStorage
- localStorage是本地缓存,也是永久缓存（在用户不清楚缓存的前提下）所以在部分得业务场景我们需要给他设置一个过期时间，在获取缓存得时候在手动判断是否过期，
- localStorage只能存储字符串，大小约为5MB
- localStroage遵循同源策略，在同一域名下同一个浏览器不同得窗口页面，操作得都是同一个localStorage 

封装了两个公告方法用于取缓存和设置缓存，同时我也在axios请求方法内置了接口缓存，核心方法也是下面的两个
```
/**
 * @description 从localstorage 设置 缓存
 * @param {String} _cacheMaxAge 过期时间 
 * @param {String} cacheKey 缓存key
 * @param {String} cacheData 缓存数据
 * 
 */
 export const setLocalStorage = (cacheKey,_cacheMaxAge,cacheData) => {
     const cache = {
         cacheTime:new Date().getTime(), // 缓存时间
         timeout:_cacheMaxAge, // 过期时间
         cache:cacheData
     }
     window.localStorage.setItem(cacheKey,JSON.stringify(cache))
 }
/**
 * @description 从localstorage 取 缓存 判断边界值 不符合条件返回null 符合条件 返回 cache response 信息
 * @param {request} 请求参数
 */
 export const getLocalStorage = (cacheKey) => {
    let cacheData = window.localStorage.getItem(cacheKey)
    const curTime = new Date().getTime()
    // 判断 cache 是否过期
    if (cacheData){
        cacheData = JSON.parse(cacheData)
        const cacheAllTime = cacheData.cacheTime + cacheData.timeout 
        // 过期了
       if (cacheAllTime - curTime <= 0) {
           remoreLocalStorage(cacheKey)
          return null
       }else{
           return cacheData.cache
       }
    }
    return null
 }
```
## SessionStorage
sessionStorage为会话缓存，其生命周期仅在当前会话下有效，只要这个浏览器没关闭，即使 进入另外一个页面,那么缓存也始终存在，
## Cookie
- Cookie一开始是解决http 无状态请求的一种方式，在第一次请求服务端的时候，服务端会根据业务场景需要设置cookie给浏览器，以后的请求 浏览器会自动把cookie携带发送给服务端
- Cookie 存储大小为4kb，如果服务端不设置过期时间，会一直存储在内存中，直到浏览器的关闭而销毁，如果设置了过期时间会存储在硬盘中